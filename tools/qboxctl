#!/usr/bin/env perl

use strict;
use warnings;

use English;
use File::Basename;

use JSON; # external library

use QBox::Auth::Digest;
use QBox::Auth::UpToken;
use QBox::Auth::Policy;
use QBox::Client;
use QBox::RS;
use QBox::UP;
use QBox::EU;
use QBox::Misc;
use QBox::ReaderAt::File;

my $conf   = undef;
my $debug  = undef;
my $pretty = undef;

sub get_param {
    foreach my $p (@_) {
        if (defined($p)) {
            return $p;
        }
    } # foreach
    return undef;
} # get_param

sub get_opts {
    my $args  = shift;
    my $opts  = {};
    my $fixed = [];

    for (my $i = 0; $i < scalar(@$args); ++$i) {
        my $arg = $args->[$i];

        if ($arg eq '-f') {
            $opts->{conf} ||= [];
            push @{$opts->{conf}}, $args->[$i + 1];
            ++$i;
            next;
        }

        if ($arg eq '-d') {
            $debug = 1;
            next;
        }

        if ($arg eq '-P') {
            $pretty = 1;
            next;
        }

        push @$fixed, $arg;
    } # for

    return $fixed, $opts;
} # get_opts

sub get_params {
    my $args = shift;
    return { map { split('=', $_, 2) } @$args };
} # get_params

sub merge_hash {
    my $to   = shift;
    my $from = shift;
    my $keys = shift || [keys(%$to)];

    foreach my $key (@$keys) {
        if (exists($from->{$key})) {
            $to->{$key} = $from->{$key};
        }
    } # foreach

    return $to;
} # merge_hash

sub get_json {
    my $text = shift;
    my $json = undef;
    
    if (-r $text) {
        open(my $fh, '<', $text) or die "$OS_ERROR";
        local $INPUT_RECORD_SEPARATOR = undef;
        $text = <$fh>;
        close($fh);
    }

    eval {
        $json = from_json($text);
    };

    if ($EVAL_ERROR) {
        return {};
    }

    return $json;
} # get_json

sub get_hosts {
    my $params = shift;
    my $hosts  = {};

    $hosts->{io_host} = get_param($params->{io_host}, $conf->{io_host});
    $hosts->{up_host} = get_param($params->{up_host}, $conf->{up_host});
    $hosts->{rs_host} = get_param($params->{rs_host}, $conf->{rs_host});

    return $hosts;
} # get_hosts

sub read_conf {
    my $fls = shift;

    my $conf = {};
    foreach my $fl (@$fls) {
        next if (not defined($fl) or $fl eq q{});

        open(my $fh, '<', $fl) or die "$!";
        local $/ = undef;
        my $text = <$fh>;
        close($fh);

        my $new_conf = undef;
        eval {
            $new_conf = from_json($text);
        };
        next if ($@);

        merge_hash($conf, $new_conf, [keys(%$new_conf)]);
    } # foreach

    return $conf;
} # read_conf

sub gen_client {
    my $params = shift;

    my $acs_key = $params->{acs_key} || $conf->{acs_key} || 'Put your ACCESS KEY here';
    my $scr_key = $params->{scr_key} || $conf->{scr_key} || 'Put your SECRET KEY here';

    my $policy = $params->{policy} || $conf->{policy};
    if (defined($policy) and $policy ne q{}) {
        $policy = QBox::Auth::Policy->new(from_json($policy));
        my $auth = QBox::Auth::UpToken->new($acs_key, $scr_key, $policy);
        return QBox::Client->new($auth);
    }

    my $auth = QBox::Auth::Digest->new($acs_key, $scr_key);
    return QBox::Client->new($auth);
} # gen_client

### rs
my $rs_get_rs_params = sub {
    my $params = shift;

    my $rs_params = {};

    $rs_params->{src_file}        = $params->{src}             || $conf->{src};
    $rs_params->{bucket}          = $params->{bkt}             || $conf->{bkt}              || 'Bucket';
    $rs_params->{key}             = $params->{key}             || $conf->{key}              || basename($rs_params->{src_file} || q{});
    $rs_params->{mime}            = $params->{mime}            || $conf->{mime}             || 'application/octet-stream';
    $rs_params->{meta}            = $params->{meta}            || $conf->{meta};
    $rs_params->{other_params}    = $params->{params}          || $conf->{params};
    $rs_params->{callback_params} = $params->{callback_params} || $conf->{callback_params};

    $rs_params->{attr}            = $params->{attr}            || $conf->{attr};
    $rs_params->{base}            = $params->{base}            || $conf->{base};
    $rs_params->{domain}          = $params->{domain}          || $conf->{domain};

    return $rs_params;
};

my $read_progress_as_plain_text = sub {
    my $fh = shift;

    my $prog = {};
    my $line = undef;

    $line = <$fh>;
    if ($line !~ m/^block_count=(\d+)\n/) {
        die "Invalid progress file: No block count.";
    }
    $prog->{blk_count} = $1;

    $prog->{checksums} = [];
    for (my $i = 0; $i < $prog->{blk_count}; ++$i) {
        $line = <$fh>;
        if ($line !~ m/^checksum=(.*)\n/) {
            die "Invalid progress file: Invalid checksum.";
        }

        push @{$prog->{checksums}}, { value => $1 };
    } # for

    $prog->{progs} = [];
    for (my $i = 0; $i < $prog->{blk_count}; ++$i) {
        my $pg = {};

        $line = <$fh>;
        if ($line !~ m/^offset=(\d+)\n/) {
            die "Invalid progress file: Invalid offset.";
        }
        $pg->{offset} = $1;

        $line = <$fh>;
        if ($line !~ m/^rest_size=(\d+)\n/) {
            die "Invalid progress file: Invalid rest size.";
        }
        $pg->{rest_size} = $1;

        $line = <$fh>;
        if ($line !~ m/^ctx=(.*)\n/) {
            die "Invalid progress file: Invalid context.";
        }
        $pg->{ctx} = $1;

        push @{$prog->{progs}}, $pg;
    } # for

    return $prog;
};

my $read_progress = sub {
    my $params = shift;
    
    my $prog_fl = $params->{prog_fl};
    return undef if (not defined($prog_fl) or $prog_fl eq q{});
    return undef if (not -r $prog_fl);

    open(my $fh, '<', $prog_fl) or die "$OS_ERROR";

    my $prog = undef;
    if ($prog_fl =~ m/json$/i) {
        local $/ = undef;
        my $text = <$fh>;
        $prog = from_json($text);
    }
    else {
        $prog = $read_progress_as_plain_text->($fh);
    }

    close($fh);
    return $prog;
};

my $write_progress_as_plain_text = sub {
    my $fh   = shift;
    my $prog = shift;

    printf {$fh} "block_count=%d\n", $prog->{blk_count};

    foreach my $cksum (@{$prog->{checksums}}) {
        printf {$fh} "checksum=%s\n", ($cksum->{value} || q{});
    } # foreach

    foreach my $pg (@{$prog->{progs}}) {
        printf {$fh} "offset=%d\n", $pg->{offset};
        printf {$fh} "rest_size=%d\n", $pg->{rest_size};
        printf {$fh} "ctx=%s\n", ($pg->{ctx} || q{});
    } # foreach
};

my $write_progress = sub {
    my $params = shift;
    my $prog   = shift;

    my $prog_fl = $params->{prog_fl};
    return if (not defined($prog_fl) or $prog_fl eq q{});

    open(my $fh, '>', $prog_fl) or die "$OS_ERROR";

    if ($prog_fl =~ m/json$/i) {
        printf {$fh} "%s", to_json($prog, { pretty => 1 });
    }
    else {
        $write_progress_as_plain_text->($fh, $prog);
    }

    close($fh);
};

my $blk_abort = sub {
    my $params    = shift;
    my $blk_index = shift;
    my $checksum  = shift;

    my $stop_idx = $params->{stop_idx};
    if (defined($stop_idx) and $blk_index == $stop_idx) {
        print "Abort uploading block(#${stop_idx}).\n";
        return 0;
    }
    return 1;
};

my $blk_notify = sub {
    my $params    = shift;
    my $blk_index = shift;
    my $checksum  = shift;

    printf "blk_index=%d, checksum=[%s]\n", $blk_index, $checksum->{value};
    $blk_abort->($params, $blk_index, $checksum);
};

my $chk_abort = sub {
    my $params    = shift;
    my $blk_index = shift;
    my $prog      = shift;

    my $stop_idx = $params->{stop_idx};
    if (defined($stop_idx) and $blk_index == $stop_idx) {
        my $stop_size = $params->{stop_size};
        if (defined($stop_size) and $prog->{offset} >= $stop_size) {
            print "Abort uploading chunk(#$prog->{stop_idx}, \@$prog->{offset}).\n";
            return 0;
        }
    }
    return 1;
};

my $chk_notify = sub {
    my $params    = shift;
    my $blk_index = shift;
    my $prog      = shift;

    printf "blk_index=%d, uploaded=%d, rest=%d, ctx=[%s]\n",
        $blk_index, $prog->{offset}, $prog->{rest_size}, $prog->{ctx};
    $chk_abort->($params, $blk_index, $prog);
};

### eu
my $eu_gen_settings = sub {
    my $params   = shift;
    my $settings = shift || {};

    my $wms   = get_param($params->{wms}, $conf->{wms});
    my $names = QBox::EU::wm_setting_names();

    merge_hash($settings, $conf, $names);
    if (defined($wms) and $wms ne q{}) {
        merge_hash($settings, get_json($wms), $names);
    }
    merge_hash($settings, $params, $names);

    return $settings;
};

my $cmds = undef;
$cmds = {
    'rs.get' => sub { # command
        my ($client, $params, $hosts) = @_;

        my $rs_params = $rs_get_rs_params->($params);
        my $rs = QBox::RS->new($client, $hosts);
        return $rs->get(
            $rs_params->{bucket},
            $rs_params->{key},
            $rs_params->{attr},
            $rs_params->{base},
        );
    },
    'rs.stat' => sub { # command
        my ($client, $params, $hosts) = @_;

        my $rs_params = $rs_get_rs_params->($params);
        my $rs = QBox::RS->new($client, $hosts);
        return $rs->stat($rs_params->{bucket}, $rs_params->{key});
    },
    'rs.publish' => sub { # command
        my ($client, $params, $hosts) = @_;

        my $rs_params = $rs_get_rs_params->($params);
        my $rs = QBox::RS->new($client, $hosts);
        return $rs->publish($rs_params->{bucket}, $rs_params->{domain});
    },
    'rs.unpublish' => sub { # command
        my ($client, $params, $hosts) = @_;

        my $rs_params = $rs_get_rs_params->($params);
        my $rs = QBox::RS->new($client, $hosts);
        return $rs->unpublish($rs_params->{domain});
    },
    'rs.put-auth' => sub { # command
        my ($client, $params, $hosts) = @_;

        my $expires_in   = $params->{expires_in} || $conf->{expires_in} || 30;
        my $callback_url = $params->{callback_url} || $conf->{expires_in};

        my $rs = QBox::RS->new($client, $hosts);
        return $rs->put_auth($expires_in, $callback_url);
    },
    'rs.put-file' => sub { # command
        my ($client, $params, $hosts) = @_;

        my $rs_params = $rs_get_rs_params->($params);

        my $rs = QBox::RS->new($client, $hosts);
        return $rs->put_file(
            $rs_params->{bucket},
            $rs_params->{key},
            $rs_params->{mime_type},
            $rs_params->{src_file},
            $rs_params->{meta},
        );
    },
    'rs.resumable-put' => sub { # command
        my ($client, $params, $hosts) = @_;

        my $rs_params = $rs_get_rs_params->($params);

        my $fsize     = (stat($rs_params->{src_file}))[7];
        my $reader_at = QBox::ReaderAt::File->new($rs_params->{src_file});

        my $notify_blk = $params->{notify_blk} || $conf->{notify_bld};
        my $notify_chk = $params->{notify_chk} || $conf->{notify_chk};

        my $notify_params = {};
        $notify_params->{stop_idx}  = get_param($params->{stop_idx}, $conf->{stop_idx});
        $notify_params->{stop_size} = get_param($params->{stop_size}, $conf->{stop_size});
        $notify_params->{prog_fl}   = get_param($params->{prog_fl}, $conf->{prog_fl});

        if (defined($notify_params->{stop_size})) {
            $notify_params->{stop_idx} ||= 0;
        }

        my $ret  = undef;
        my $err  = undef;
        my $prog = $read_progress->($notify_params);

        my $rs = QBox::RS->new($client, $hosts);
        ($ret, $err, $prog) = $rs->resumale_put(
            $prog,
            defined($notify_blk) ? $blk_notify : $blk_abort,
            defined($notify_chk) ? $chk_notify : $chk_abort,
            $notify_params,
            qbox_make_entry($rs_params->{bucket}, $rs_params->{key}),
            $rs_params->{mime},
            $reader_at,
            $fsize,
            $rs_params->{meta},
            $rs_params->{other_params},
            $rs_params->{callback_params},
        );

        if ($err->{code} != 200) {
            $write_progress->($notify_params, $prog);
        }
        elsif ($notify_params->{prog_fl} and -w $notify_params->{prog_fl}) {
            unlink($notify_params->{prog_fl});
        }

        return $ret, $err;
    },
    'rs.delete' => sub { # command
        my ($client, $params, $hosts) = @_;

        my $rs_params = $rs_get_rs_params->($params);
        my $rs = QBox::RS->new($client, $hosts);
        return $rs->delete($rs_params->{bucket}, $rs_params->{key});
    },
    'rs.drop' => sub { # command
        my ($client, $params, $hosts) = @_;

        my $rs_params = $rs_get_rs_params->($params);
        my $rs = QBox::RS->new($client, $hosts);
        return $rs->drop($rs_params->{bucket});
    },
    'up.query' => sub { # command
        my ($client, $params, $hosts) = @_;

        my $prog_fl = get_param($params->{prog_fl}, $conf->{prog_fl});
        my $prog    = $read_progress->({ prog_fl => $prog_fl });

        if (not defined($prog)) {
            return undef, { code => 299, message => 'No correct progress infomation.' };
        }

        my $up = QBox::UP->new($client, $hosts);
        return $up->query($prog->{checksums});
    },
    'eu.wmget' => sub { # command
        my ($client, $params, $hosts) = @_;

        my $customer = get_param($params->{customer}, $conf->{customer});
        my $eu = QBox::EU->new($client, $hosts);
        return $eu->wmget($customer);
    },
    'eu.wmset' => sub { # command
        my ($client, $params, $hosts) = @_;

        my $settings = $eu_gen_settings->($params);
        my $eu = QBox::EU->new($client, $hosts);
        return $eu->wmset($settings);
    },
    'eu.wmset-any' => sub { # command extended
        my ($client, $params, $hosts) = @_;

        my ($settings, $err) = $cmds->{'eu.wmget'}->($client, $params, $hosts);
        if ($err->{code} != 200) {
            return undef, $err;
        }

        $settings = $eu_gen_settings->($params, $settings);
        my $eu = QBox::EU->new($client, $hosts);
        return $eu->wmset($settings);
    },
};

my ($args, $opts) = get_opts(\@ARGV);
$conf = read_conf($opts->{conf});

my $cmd = shift(@$args);

if (not defined($cmd)) {
    my $prog_nm = basename($0);
    print "Usage: ${prog_nm} CMD [PARAM=ARG [PARAM=ARG [...]]]\n";
    exit(1);
}

if (not defined($cmds->{$cmd})) {
    print "No such command.(cmd=${cmd})\n";
    exit(1);
}

if ($debug) {
    QBox::Debug::set_callback(sub {
        my $data    = shift;
        my $title   = shift;
        my $context = shift;

        my $type = ref($context);
        if ($type eq 'HASH') {
            printf "${title}=%s\n", to_json($context, { pretty => $pretty });
        }
        else {
            print "${title}=[${context}]\n";
        }
    });
}

my $params = get_params($args);
my $hosts  = get_hosts($params);
my $client = gen_client($params);

my ($ret, $err) = $cmds->{$cmd}->($client, $params, $hosts);

$ret ||= {};
printf "ret=%s\n", to_json($ret, { pretty => $pretty });
printf "code=%d\nmessage=[%s]\n", $err->{code}, $err->{message};

exit 0;
